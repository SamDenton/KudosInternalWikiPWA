@page "/mainContent/{type}/{sections?}"
@using System.Net
@using System.Net.Http;
@using System.Net.Http.Headers;
@using Newtonsoft.Json;
@inject HttpClient Http;
@inject NavigationManager Navigation;
@* Using Authorize View to only load content when user is authenticated.  If not logged in, they should be redirected to a Microsoft authenticator *@
<AuthorizeView>
    <Authorized>
        <PageTitle>Barcode Scanners</PageTitle>
        @* Still not sure if I want 2-3 pages total with sections, or a page for each section *@
        @* Either way, I think i will need a different JSON file for each page *@
        
        <div>
            <h1>@type: <small class="text-muted">@sections </small></h1>
            @* Show a loading message before API call is complete *@
            @* Might add a timer so it displays a different message if the request takes too long *@
            @* Should also add failure case if the API call returns 404 *@
            @if (contentHolderList == null)
            {
                <p><em>Loading...</em></p>
            }
            else
            {
                var count = 0;
                var clearText = "";
                <table class="table table-dark table-striped">
                    <thead>
                        <tr>
                            <th class="col-1">Section</th>
                            <th>Content</th>
                        </tr>
                    </thead>
                    <tbody>
                        @* Pragmatically populate the table using my customer object array *@
                        @foreach (var contentHolder in contentHolderList)
                        {
                            @if (type == contentHolder.page && sections == contentHolder.section)
                            {
                                <tr>
                                    @* Currently showing all details about the section, but once I split into multiple pages, this will likley be hidden *@
                                    <td><p>@contentHolder.page: <small class="text-muted">@contentHolder.section</small></p></td>
                                    @* Render the de-serialized JSON string as HTML, including styling.  I need some sanitisation here but AntiXss from Microsoft is broken ATM... *@
                                    <td hidden="@IsEditing[count]">@(new MarkupString(@contentHolder.content))</td>
                                    @* When IsEditing is true, render the WYSIWYG editor, i'm using TinyMCE *@
                                    <td hidden="@(!IsEditing[count])"><div class="dotted-lines">
                                        <Editor
                                            Id="@count.ToString()"
                                            Inline=false
                                            CloudChannel="5"
                                            Disable=false
                                            Conf="@editorConf"
                                            ApiKey="7so5re0foy5ocvnv7m3m3rznoi0hiar7wrg9w0hk2bkgfshl"
                                            ClassName="counterEditor"
                                            @bind-Value=(contentHolder.content)
                                        /> 
                                    </div></td>
                                </tr>
                                @* Initiate localCount here to button onclick events use the count at create time, not when clicked *@
                                var localCount = count;
                                <tr>
                                    <td>
                                        @* Spacing *@
                                    </td>
                                    @* Button bank to be generated per section.  Using lambda expression to parse value to function *@
                                    <td><button class="btn btn-outline-warning" @onclick="(() => {contentHolder.content = clearText;})">Clear</button>
                                    <button class="btn btn-outline-danger" @onclick="(() => RemoveSection(localCount))">Delete</button>
                                    <button class="btn btn-outline-primary" @onclick="(() => Edit(localCount))" hidden="@IsEditing[localCount]">Edit</button>
                                    <button class="btn btn-outline-primary" @onclick="(() => Save(localCount))" hidden="@(!IsEditing[localCount])">Save</button>
                                    <button class="btn btn-outline-primary" @onclick="(() => Cancel(localCount))" hidden="@(!IsEditing[localCount])">Cancel</button></td>
                                </tr>
                                @* Increment global count *@
                                count++;
                            }
                            else if (type == contentHolder.page && sections == "all" || type == null )
                            {
                                @if (type == null)
                                {
                                    type = "Misc (autoselected as missing type)";
                                }
                                <tr>
                                    @* Currently showing all details about the section, but once I split into multiple pages, this will likley be hidden *@
                                    <td><p>@contentHolder.page: <small class="text-muted">@contentHolder.section</small></p></td>
                                    @* Render the de-serialized JSON string as HTML, including styling.  I need some sanitisation here but AntiXss from Microsoft is broken ATM... *@
                                    <td hidden="@IsEditing[count]">@(new MarkupString(@contentHolder.content))</td>
                                    @* When IsEditing is true, render the WYSIWYG editor, i'm using TinyMCE *@
                                    <td hidden="@(!IsEditing[count])"><div class="dotted-lines">
                                        <Editor
                                            Id="@count.ToString()"
                                            Inline=false
                                            CloudChannel="5"
                                            Disable=false
                                            Conf="@editorConf"
                                            ApiKey="7so5re0foy5ocvnv7m3m3rznoi0hiar7wrg9w0hk2bkgfshl"
                                            ClassName="counterEditor"
                                            @bind-Value=(contentHolder.content)
                                        /> 
                                    </div></td>
                                </tr>
                                @* Initiate localCount here so button onclick events use the count at create time, not when clicked *@
                                var localCount = count;
                                <tr>
                                    <td>
                                        @* Spacing *@
                                    </td>
                                    @* Button bank to be generated per section.  Using lambda expression to parse value to function *@
                                    <td><button class="btn btn-outline-warning" @onclick="(() => {contentHolder.content = clearText;})">Clear</button>
                                    <button class="btn btn-outline-danger" @onclick="(() => RemoveSection(localCount))">Delete</button>
                                    <button class="btn btn-outline-primary" @onclick="(() => Edit(localCount))" hidden="@IsEditing[localCount]">Edit</button>
                                    <button class="btn btn-outline-primary" @onclick="(() => Save(localCount))" hidden="@(!IsEditing[localCount])">Save</button>
                                    <button class="btn btn-outline-primary" @onclick="(() => Cancel(localCount))" hidden="@(!IsEditing[localCount])">Cancel</button></td>
                                </tr>
                                @* Increment global count *@
                                count++;
                            }
                        }
                        @if (type == "add" && IsEditing[0] == true)
                        {
                            var localCount = 0;
                            count = 0;
                            <tr>
                                <td>New Section: </td>
                                @* Render the de-serialized JSON string as HTML, including styling.  I need some sanitisation here but AntiXss from Microsoft is broken ATM... *@
                                <td hidden="@IsEditing[count]">@(new MarkupString(contentHolderList.Last().content))</td>
                                <td hidden="@(!IsEditing[count])"><div class="dotted-lines">
                                    <Editor
                                        Id="@count.ToString()"
                                        Inline=false
                                        CloudChannel="5"
                                        Disable=false
                                        Conf="@editorConf"
                                        ApiKey="7so5re0foy5ocvnv7m3m3rznoi0hiar7wrg9w0hk2bkgfshl"
                                        ClassName="counterEditor"
                                        @bind-Value=(contentHolderList.Last().content)
                                    /> 
                                </div></td>
                            </tr>
                        @* Initiate localCount here to button onclick events use the count at create time, not when clicked *@
                        <tr>
                            <td>
                                @* Spacing *@
                            </td>
                            @* Button bank to be generated per section.  Using lambda expression to parse value to function *@
                            <td><button class="btn btn-outline-warning" @onclick="(() => {contentHolderList.Last().content = clearText;})">Clear</button>
                            <button class="btn btn-outline-danger" @onclick="(() => RemoveSection(localCount))">Delete</button>
                            <button class="btn btn-outline-primary" @onclick="(() => Edit(localCount))" hidden="@IsEditing[localCount]">Edit</button>
                            <button class="btn btn-outline-primary" @onclick="(() => Save(localCount))" hidden="@(!IsEditing[localCount])">Save</button>
                            <button class="btn btn-outline-primary" @onclick="(() => Cancel(localCount))" hidden="@(!IsEditing[localCount])">Cancel</button></td>
                        </tr>
                        }
                    </tbody>
                </table>
            }
        </div>
        <div>
            @if (type == "add")
            {
            @* Section for adding a new section from user selection *@
            @* Using bootstraps grid layout for formatting *@
                <div class="bg-dark text-primary container-fluid">
                    <div class="row">
                        <div class="col-6">
                            @* Dropdown for section type *@
                            <div class="form-group">
                                <label class="form-label bg-dark text-light" for="sectionDropdown">Select New Section Type:</label>
                                <select class="form-control form-control-dark bg-dark text-primary border-primary" id="sectionDropdown" @bind="sectionDropdown">
                                    <option value="Default" disabled selected>Select a type</option>
                                    <option value="Hardware">Hardware</option>
                                    <option value="Software">Software</option>
                                    <option value="Misc">Misc</option>
                                </select>
                            </div>
                            @* Text field for section name *@
                            <div class="form-group bg-dark text-primary">
                                <label class="form-label bg-dark text-light mt-1" for="sectionContent">Section Name:</label>
                                <input type="text" class="form-control form-control-dark bg-dark text-primary border-primary" id="sectionContent" placeholder="Name of the new section" @bind="sectionName">
                            </div>
                            @* Add section button *@
                            <button class="btn btn-outline-primary mt-2" @onclick="(() => AddNewSection())">Add New Section</button>
                        </div>
                        <div class="col-6">
                            @* Spacing *@
                        </div>
                    </div>
                </div>            
            }
        </div>

    </Authorized>
    <NotAuthorized>
        @* If user is not authorized, call RedirectHome *@
        <p>Please Login to see this Content.  Redirecting...</p>
        @if(!context.User.Identity.IsAuthenticated)
        {
            RedirectHome();
        }
    </NotAuthorized>
</AuthorizeView>
@code {
    @* Declare custom object array *@
    public contentHolder[]? contentHolderList;
    public contentHolder[] ContentHolderListState;
    @* Declare var for current user selection *@
    [Parameter]
    public string? type { get; set; }
    [Parameter]
    public string? sections { get; set; }
    @* Declare Global Vars *@
    private string[] initialContent;
    private bool[] IsEditing;
    private string sectionDropdown;
    private string sectionName;
    @* Declare/Initialize variables for API communication *@
    private string repoName = "WikiData";
    private string userName = "SamDenton";
    private string token;
    private string commitText = "Test From Wiki";
    private string newSHA; 
    @* Initialize page.  Using Async initialization as I want to load content from API before rendering *@
    protected override async Task OnInitializedAsync()
    {
    @* Get API token from external file.  Token.txt is not included in Commits.  Should probably do the same with my TinyMCE token *@
        var getFromTokens = await Http.GetAsync("Token.txt");
        token = await getFromTokens.Content.ReadAsStringAsync();
    @* Call method to make GET request *@
        contentHolderList = await GetContentFromGitHubRepo<contentHolder>(userName, repoName, token);
    @* Initialize control variables after populating contentHolderList *@
        initialContent = new string[contentHolderList.Length];
        IsEditing = new bool[contentHolderList.Length];
        ContentHolderListState = contentHolderList;
        base.OnInitialized();
    }
    @* Currently actually redirects to Microsoft Authentication popup, but might change this to home *@
    protected private void RedirectHome()
    {
        Navigation.NavigateTo($"authentication/login?returnUrl={Uri.EscapeDataString(Navigation.Uri)}");
    }
    @* Method to clear specific sections content *@
    private void ClearContent(int sectionNo)
    {
        contentHolderList[sectionNo].content = "";
    }
    @* Set selected sections IsEditing to True, which should render the editor *@
    private void Edit(int sectionNo)
    {
        Console.WriteLine(sectionNo);
    @* When you click edit, save the current state so 'Cancel' button can revert changes *@
        initialContent[sectionNo] = contentHolderList[sectionNo].content;
        IsEditing[sectionNo] = true;
    }
    @* Set selected section's IsEditing to false, then call method to PUT new JSON to GitHub.  Should render updated content to DOM *@
    private async void Save(int sectionNo)
    {
        IsEditing[sectionNo] = false;
    @* Update the array for navigation *@
        ContentHolderListState = contentHolderList;
        StateHasChanged();
    @* Serialize current object array to a JSON String *@
        var jsonString = JsonConvert.SerializeObject(contentHolderList);
        await UpdateJSONOnGitHub(jsonString, repoName, userName, token, commitText, newSHA);
    }
    @* Set sections IsEditing to false, and set the content to the stored previous state *@
    private async void Cancel(int sectionNo)
    {
    @* If statement needed here so canceling on a newly added section will remove it *@
        if (initialContent[sectionNo] != null)
        {
            contentHolderList[sectionNo].content = initialContent[sectionNo];
        }
        else
        {
            await RemoveSection(contentHolderList.Length - 1);
        }
        IsEditing[sectionNo] = false;
    }
    @* Add a new object to my array from user input *@
    private void AddNewSection()
    {
    @* Using data binding to tie user selection to these vars *@
        var type = sectionDropdown;
        var name = sectionName;
        if (!String.IsNullOrWhiteSpace(type) && !String.IsNullOrWhiteSpace(name)) @* type != null && type != "" && type != " " && name != null && name != "" && name != " " *@
        {
    @* Best way to add to an array is to resize then initialize the new index *@
            Array.Resize(ref contentHolderList, contentHolderList.Length + 1);
            Array.Resize(ref IsEditing, IsEditing.Length + 1);
            contentHolderList[contentHolderList.Length - 1] = new contentHolder { 
                page = type, 
                section = name, 
                content = "<p>Enter some details about " + name + " here.</p>" 
            };
            ReInitialize();
    @* Initialize new index on control variables *@
            IsEditing[0] = true;
            Console.WriteLine(contentHolderList.Length - 1);
        }
        else
        {
    @* Should add an alert or style change to the entry box here to show a value is needed *@
        }
    }
    @* Method to remove selected section *@
    private async Task RemoveSection(int sectionNo)
    {
    @* Easiest way to remove an element from middle of array is to build a new array from the old, skipping the line to remove, then setting it back to main array *@
        contentHolder[] newArray = new contentHolder[contentHolderList.Length - 1];
        int newArrayIndex = 0;
        for (int i = 0; i < contentHolderList.Length; i++)
        {
            if (i != sectionNo)
            {
                newArray[newArrayIndex++] = contentHolderList[i];
            }
        }
        contentHolderList = newArray;
        ReInitialize();
    @* Serialize and upload to GitHub *@
        var jsonString = JsonConvert.SerializeObject(contentHolderList);
        await UpdateJSONOnGitHub(jsonString, repoName, userName, token, commitText, newSHA);
    }
    @* This method should reset lengths of different variables and re-load the page.  Called after a number of state changes *@
    private void ReInitialize()
    {
        initialContent = new string[contentHolderList.Length];
        IsEditing = new bool[contentHolderList.Length];
        StateHasChanged();
    }
    @* Method for uploading content to GitHub API via PUT *@
    private async Task UpdateJSONOnGitHub(string jsonString, string repositoryName, string username, string token, string commitMessage, string sha)
    {
    @* Since I'm injecting a Http client for Token GET I dont know if i need to declare new clients for each method, but its working *@
        using (var client = new HttpClient())
        {
    @* Initialize the HttpClient object with an authorization header and desired content type *@
            client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Token", token);
            client.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/vnd.github+json"));
    @* Define the request body, encoding the content string as base64 *@
            var body = new
            {
                message = commitMessage,
                content = Convert.ToBase64String(Encoding.UTF8.GetBytes(jsonString)),
                sha = sha
            };
    @* Serialize the body object and encode *@
            var json = JsonConvert.SerializeObject(body);
            var contentAndMessage = new StringContent(json, Encoding.UTF8, "application/json");
    @* Send the PUT request to the GitHub API *@
            var response = await client.PutAsync($"https://api.github.com/repos/{username}/{repositoryName}/contents/data.json", contentAndMessage);
            var responceHeaders = await response.Content.ReadAsStringAsync();
    @* Get new sha value from PUT response headers *@
            var gitContent = JsonConvert.DeserializeObject<Root>(responceHeaders);
            newSHA = gitContent.content.sha;
    @* Ensure the request was successful *@
            response.EnsureSuccessStatusCode();
        }
    }
    @* Retrieve content from GitHub as a JSON string *@
    public async Task<T[]> GetContentFromGitHubRepo<T>(string username, string repositoryName, string token)
    {
        using (var client = new HttpClient())
        {
    @* Initialize the HttpClient object with an authorization header and desired content type *@
            client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Token", token);
            client.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/vnd.github+json"));
    @* Send the GET request to the GitHub API *@
            var response = await client.GetAsync($"https://api.github.com/repos/{username}/{repositoryName}/contents/data.json");
    @* Read the response content, parse the content and convert it from base64, then de-serialize the content with my custom class *@
            var content = await response.Content.ReadAsStringAsync();
            var gitContent = JsonConvert.DeserializeObject<Content>(content);
            var contentBytes = Convert.FromBase64String(gitContent.content);
            var jsonContent = Encoding.UTF8.GetString(contentBytes);
            var array = JsonConvert.DeserializeObject<T[]>(jsonContent);
    @* Get the sha of the retrieved file *@ 
            newSHA = gitContent.sha;
    @* Not using this return.  I might be able to remove the return type <T[]> from the method deceleration *@
            return array;
        }
    }
    @* Not using this method currently, but might be useful if I split content across pages / files on GitHub *@
    @* If I end up using this method, I should re-write to match the format of my GET and PUT methods*@
    private async Task DeleteFile(string repositoryName, string username, string token, string commitMessage, string sha)
    {
        var client = new HttpClient();
        client.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Token", token);
        var content = new StringContent("{\"message\":\"" + commitMessage + "\",\"sha\":\"" + sha + "\"}", Encoding.UTF8, "application/json");
        var response = await client.DeleteAsync($"https://api.github.com/repos/{username}/{repositoryName}/contents/data.json");
        if (!response.IsSuccessStatusCode)
        {
            throw new Exception("Error deleting file: " + response.ReasonPhrase);
        }
    }
    @* Class for creating custom objects from JSON string *@
    public class contentHolder
    {
        public string? page { get; set; }

        public string? section { get; set; }

        public string? content { get; set; }
    }

    public class ContentHolderState
    {
        public contentHolder[] ContentHolderListState { get; set; }
    }
    @* Class for creating an object from GET response. content here will still be JSON string, so needs de-serializing further using previous class *@
    public class Content
    {
        public string content { get; set; }
        public string encoding { get; set; }
        public int size { get; set; }
        public string sha { get; set; }
    }
    @* Class structure to get sha from PUT response headers *@
    public class Root
    {
        public PutResponse content { get; set; }
    }
    public class PutResponse
    {
        public string sha { get; set; }
        public string content { get; set; }
        public string commit { get; set; }
        public string url { get; set; }
    }
    @* Define properties for TinyMCE WYSIWYG editor *@
    private Dictionary<string, object> editorConf = new Dictionary<string, object>  {
        {"menubar", "edit insert format table tools help"}, @* Would like to condence toolbar in to a few dropdowns, but converting JS syntax to C# is a pain *@
        {"toolbar", "undo redo | bold italic underline strikethrough | fontfamily fontsize blocks | alignleft aligncenter alignright alignjustify | outdent indent |  numlist bullist | forecolor backcolor removeformat | pagebreak | charmap emoticons | fullscreen  preview save print | insertfile image media template link anchor codesample | ltr rtl"},
        {"plugins", "link image table lists advlist code emoticons wordcount importcss autoresize"}, //imagetools spellchecker - Removed as imagetools now premium and spellchecker depricated
        {"contextmenu", "link image imagetools table spellchecker lists"},
        {"table_toolbar", "tableprops tabledelete | tableinsertrowbefore tableinsertrowafter tabledeleterow | tableinsertcolbefore tableinsertcolafter tabledeletecol"},
        {"width", "100%"},
        {"min_width", "100%"},
        {"height", "100%"}, @* Using autosize plugin, height property should be ignored. Min_height still respected *@
        {"min_height", 100},
        {"autoresize_bottom_margin", 50},
        {"skin", "oxide-dark"},
        {"content_css", "dark"},
        {"autosave_ask_before_unload", "true"},
        {"resize", "both"} @* Allows user to resize using bottom right corner.  Should still respect min height and width *@
    };
}
